# 作弊与反作弊系统

###### `by vis2k`

翻译By J&W 以及本人的学徒
本文由Mirror的作者进行编纂,吾只负责进行校队.

本人的学徒仅仅使用机翻,使用谷歌翻译进行翻译,仅此而已,如有异议,自行翻译则能够得到和他完全一样的版本,并没有使用任何的专业术语进行润色,为了避免后续争端,写这句话.

我的贡献: 95%
他的贡献: 5% 把文字复制下来并使用谷歌翻译

权限: Authority

## 介绍

​		追溯到2009-2015年，在我开始制作`《Mirror & uMMORPG》`之前，我尝试着通过逆向工程去了解`MMOs`并通过出售挂机外挂谋生。在此，我将分享一些基于我们的分歧中所提出的问题所总结的一些经验。此外，这篇文章是不完善的，我将通过一个简短的介绍来说明在我们讨论的分歧中，最常提及的话题。当然，如果你想知道更多信息，请联系我。

​		首先我们将了解Server-Authority和客户端权限，这是我们首先要解决的问题。我们还将讨论独立于权限的攻击以及如何防范它们。

> ​		经验之谈，永远不要相信Client.

## Server-Authority vs ClientAuthority

​		最重要的事，在默认情况下，Mirror是由Server进行逻辑处理的。换句话说，Server做出所有逻辑处理。
     外挂开发者通常入侵客户端来开挂。在这种情况下，

​		换句话说，只要在有人入侵你的Server之前改用Server-Authority，将不会存在问题。如果你在游戏的某些部分(如移动)中使用了Client-Authority，那么这些就是你需要担心的部分。

​		明确一点，使用生命药水解释两种Authority之间的区别。

| Server-Authority | Client-Authority |
| --- | --- |
| 玩家：我可以使用这瓶药水吗？   |   玩家：我使用这种药剂，我的生命值将回复至100！|
|Server：验证中······        |     Server：¯\\_(ツ)_/¯|
 Server:你的新生命值是100! | |

​		在实践中，您需要效验[Commands]中的任何变量。以下是一个开发者开发一款由Mirror制作的游戏的视频，其中开发者没有核实客户端数值输入。游戏可能有如下的````CmdSellltem````功能:

````
[Command
void CmdSellItem(int slot, int amount)
{
    // get player's item at inventory slot
    Item item = player.inventory[slot];
    
    // sell to npc
    item.amount -= amount;
    player.gold += item.price * amount;
}
````

​		请注意我们是如何盲目地相信玩家发送的数据。这里没有做任何校验。如果玩家只有一个道具，但黑客发送‘amount= 100’，Server任会按照100个道具进行出售处理。相反，我们需要**验证任何玩家的输入**:

````
[Command
void CmdSellItem(int slot, int amount)
{
    // valid slot?
    if (0 <= slot && slot <= player.inventory.Count)
    {
        // get player's item at inventory slot
        Item item = player.inventory[slot];
        
        // valid amount?
        if (0 < amount && amount <= item.amount)
        {
            // sell to npc
            item.amount -= amount;
            player.gold += item.price * amount;
        }
    }
}
````



## ClientAuthority——万恶之源

**让Client进行移动的逻辑**

​		如果默认情况下Mirror是完全使用Server-Authority的，而Client-Authority允许作弊，那么为什么还会有人使用Client-Authority呢?

​		因为它很简单。许多游戏一开始或一直使用Client-Authority进行移动。在Server-Authority中，Client必须在每次操作之前询问Server

> 按下按钮,询问服务器是否可以按, 服务器说可, 移动, 然后再把数值返回
> 因此现在的游戏使用的都是类似Minecraft的, 客户端和服务器同时进行计算, 服务器检测数值,如果数值超出,则使用服务器自己计算的数值进行同步/覆盖.

​		在Client-Authority模式下，玩家一按下该键就会移动。**它不是要求Server进行移动的逻辑处理**，而是告诉Server它移动了,让Server告诉其他连接的客户端。这很不错,但是 Client可以随时设置Transform的数值

​		多人游戏的移动的设计很难,不过UE4和DOTS技术早就解决了.
       。快速移动也可能是Server-Authority的(`rubberbanding / prediction /etc.`)，但为了节省几个月的开发时间,许多人一开始选择不这么做.

**相信来自Client的数值**

​		在有些游戏类型，比如第一人称射击游戏中，不可避免地要把游戏的某些部分交给客户。比如瞄准这个部分,即(yaw,pitch,roll)。但只要我们信任来自客户端的数值，黑客就可以通过修改这些数值来作弊。在FPS游戏中，**自瞄辅助**可以假装将鼠标更快地移动到另一个玩家身上的操作。而且由于Server直接采用Client的数值，这就为自瞄作弊,开了一条小路。

> 总而言之，我们可能希望或需要在游戏的某些部分上信任客户。这些是我们需要防止作弊的部分。

> 黑客可以抓包和改包.

## Server授权“作弊”

​		需要明确的是，即使是像`MMOs`这样100%Server-Authority的游戏，仍然存在可攻击的向量。本文的重点是首先考虑对Client-Authority的**最明显的攻击**。即使Server不相信客户端，从技术上讲，除了自动执行和玩家手动执行的任务外，技术上不作弊的机器人任有空间。

​		**机器人**是一种分析游戏状态并在玩家不在时自动获取金币或杀死怪物的工具。有些玩家甚至会使用数百个**机器人**去农场，然后用游戏中的金币去换取真钱。

> 记住，Server-Authority相关的作弊是**一个奢侈的问题**。如果你的`MMO`大获成功，以至于人们开始开发挂机辅助，那么你已经算是非常成功了。

​		防止Server-Authority相关的“作弊”已经不是单纯的开发可以解决了。机器人的作用,只能用于挂机自动搜集,不会造成很大的伤害。

​		需要说明的是，在客户端和Server端都可以**检测到机器人**。但是当问题出现的时候要担心5年后，而不是现在。

## 作弊是如何产生的

​		让我们快速了解一下作弊是如何发生的。

​		你的游戏在内存中存储了大量相关信息。例如:本地玩家的位置，其他玩家的位置，怪物的位置，生命值，名字等等。

**发现内存位置**

​		大多数作弊者需要从游戏内存中读取一些信息。像**Cheat Engine**这样的工具可以让你在游戏内存中搜索特定的值。例如，如果您的健康值为100，那么您搜索“100”，可能会在内存中找到10,000个值为“100”的位置。但如果你服用药剂并将生命值增加到200，那么你便可以将其缩小到之前的“100”，现在则改为“200”。如果这样做几次，那么通常可以将其缩小到内存中的一个位置。例如，本地播放器的运行状况可能存储在内存地址````0xAABBCCDD````。

​		但这里存在一个**问题**:当我们下次开始游戏时，游戏将再次设置世界，而玩家的生命值将不再位于相同的内存地址。像Cheat Engine这样的工具可以让你通过设置断点来“**找到访问那个内存位置的东西**”。再次使用药剂，断点就会触发，现在你就知道游戏的哪个部分会访问那个内存位置。

​		而不仅仅是````血量````,你现在有````一个生命值为health````的玩家(这是一个简化，在实践中，你从````0xAABBCCDD````到一个带有偏移量的指针，如````[0x00FF00FF+0x8]````，其中````0x00FF00FF````是你的玩家对象在内存中的位置),````0x8````是````玩家->生命值````的偏移量。很可能玩家的>法力值会达到````+0x12````,或者在内存的下一个位置。这个过程可以重复，直到你有````游戏->玩家->生命值````，````游戏````最终是一个相对于程序入口点的地址。

​		换句话说，我们现在甚至可以在重新开始游戏后读取玩家的命值。

​		这个过程可以在库存、技能、怪物、位置等方面重复。我们能找到的信息越多，就越容易开发作弊程序。

​		如果我们的游戏使用**客户端权限**，那么我们就可以在内存中修改玩家的生命值!如果我们使用Server-Authority，那么我们仍然可以在内存中修改它，但是修改只在这个Client上可见。Server不将运行状况信任给客户端，下次将新的运行状况同步到客户端时，内存中的值将再次被覆盖。

> 这就是`Mirror的[SyncVar]`的工作原理!您可以在Cheat Engine中修改它们，但没有人关心，因为它们是Server授权的。

**让查找内存位置更加困难**

​		通过指针和偏移量查找内存位置的过程很麻烦。每当游戏发生变化，补偿也会发生变化。例如，如果之前我们有像：

````class Player
{
    int Level; // at +0 in memory
    int Health; // at +4 in memory
    int Mana; // at +8 in memory
}````
````

​		游戏改为:

````class Player
{
    int Class; // at +0 in memory
    int Level; // NOW at +4 in memory
    int Health; // NOW at +8 in memory
    int Mana; // NOW at +12 in memory
}````
````

​		然后，欺骗开发人员将不得不再次手动搜索内存中的所有偏移量。这个处理过程会有点让人痛苦。

> 偶尔打乱内存布局是使逆向工程更加困难的好方法。防止逆向工程是**回报与努力**的函数。如果黑客每个月只能赚10美元，没人会每天花10个小时去做逆向工程。我们做得越难，就越不值得。

> **保护内存值**

​		这里有一个有趣的小技巧，可以在任何游戏中使用，没有太多风险。与其直接存储游戏中的数值，**我们可以存储如下的预期值**:

````struct AntiCheatInt
{
    int projected;
    public int Value
    {
        get => projected + 1;
        set => projected = value - 1;
    }
}````
````

​		这是一个简化的示例，但其逻辑是是不要将我们的“100”生命值直接存储在内存中。相反，我们存储被一个或更复杂的投影修改过的值。这已经使得整个作弊引擎的初始查找过程非常令人沮丧，同时几乎没有增加任何风险。如果你在Unity中这么做，就不会出现任何问题。

> 映射内存值是一种容易使作弊开发变得更加恼人的方法。注意，这对性能有轻微的影响，并且只有在Unity中使用`IL2CPP`时才有用。

> 当保护玩家不受外挂干扰时，他们需要在让作弊者的生活更加艰难和不惹恼诚实玩家之间找到平衡。有些技术，比如```UPX```打包(见下文)，很有可能会惹恼所有人。其他技术，比如投射记忆，惹恼任何人的可能性很低。

**使访问内存变得困难**

​		有各种各样的技术使逆向工程开始时更加困难。例如:

- **动态变化的假入口点(加壳)**，例如使用`UPX封隔器等exe包装`。这些不是很难打开，但它增加了难度。

- - 注意，`UPX`包装的可执行文件经常被标记为病毒。

- 通过````IsDebuggerPresent````检测像````Cheat Engine/MHS````这样的**调试器**。注意，这很容易解决，因为每个人都知道````IsDebuggerPresent arleady````。更高级的技术可能包括一些技巧，比如测量指令之间的时间间隔。例如，如果我们在**运行时用秒表测量**一个简单的整数乘法，它最终会花费几毫秒的时间，那么很可能有人会用调试器逐步执行这段代码。

- 使用像`Themida`或`Enigma Packer`这样的工具进行**虚拟化**是防止逆向工程的宗旨。如果在常规进程中很难找到内存位置，那么在虚拟机内部的进程中更难找到内存位置。当我们使用逆向工程游戏时，我们永远不会触及虚拟过程，因为所付出的努力与回报根本不值得。没有人会花半年时间分析你的虚拟机指令，除非你的游戏像《魔兽世界》那样庞大。

- - 注意，虚拟化的可执行文件通常被标记为病毒。您需要一个没有标记为病毒的自定义虚拟化引擎。

- > **注意**，这些技术在Unity中有很多风险，**Unity**已经从**c# ->IL(->IL2CPP->Assembly)**引入了好几层复杂性。在某个地方，错误的进入点破坏东西的可能性很高。根据经验，在任何情况下都应该使用**IL2CPP**，因为它将游戏从IL更改为Assembly，而这已经很难进行逆向工程了。如果作弊成为一个严重的问题，考虑虚拟化。

> 说实话,你使用Unity基本上源代码就公诸于世了,我不太明白为什么原作者这么说



既然我们已经了解了外挂是如何产生的，我们就来看看一些常见的外挂是如何起作用的，以及如何防范它们。

## Ollydbg/IDA/Code Caves

假设你的游戏有如下功能:

````void SetHealth(int health)
{
    this.health = health;
}````
````

这可能产生(简化的)汇编代码，如:

````...
mov edi, eax // edi is this.health, eax is the new value
...
````

黑客可以使用高级的调试工具修改你的游戏的汇编码，以:

````...
mov edi, 100 // always sets health to 100
...
````

​		与使用作弊引擎搜索和修改内存值不同，它可以**直接修改游戏**自己的汇编代码。

​		修改游戏的组件对于开发黑客来说是非常强大的。代码通道通常被用来将定制函数注入游戏中，例如:

````...
JMP 4 // jump to our custom code
...
mov edi, eax // do the original thing
... custom code ... // do whatever we want
JMP 2 // jump back to the original function
...````
````

​		在C#中，这相当于用户将自己的代码注入到我们的生命值函数中，如下所示:

````void SetHealth(int health)
{
    CodeCave(health);
}

void CodeCave(int health)
{
    this.health = health;
    // do all kinds of magic here
    // for example, if health==0 then call the code
    // that clicks on the Respawn button to respawn
    // automatically.
}````
````

​		这是一个简化的例子，但却是一个非常常见的技巧。为了防止自定义程序集，明智的做法是对生成的`exe`文件的校验(md5,sha256...)。



## 透视作弊(Wall Hacks / ESP)

​		在第一人称射击游戏中，涂鸦墙是最常见的作弊方式之一。人们可以修改你的可执行文件，让玩家看到墙后的场景。这很容易做到，也很常见。

​		这是防止它的方法：

- 使逆向工程尽可能困难(见上一章)。

- 使用Mirror的InterestManager以不显示远处的玩家。如果他们确实被看到的话，你可以执行基于**InterestManager**的射线检测，地方玩家,才会被发送给客户端。
> 虚幻4从设计的根本,就解决了这个问题(actor的同步范围)
> 说白了,服务器认为你看不到这个玩家,或者距离过远,就直接不给你现实,不告诉你客户端玩家在这里.

- 在运行时检测透视作弊程序并禁止作弊者使用他们。

  ​	这是一个困难的问题，即使是像《反恐精英》这样的热门游戏也很难处理这个问题。这是一场持久战。



## 攻击速度

​    如果你选择使用Client-Authority移动，因为这样更容易，那么你很可能会在你的游戏中遇到Speed-Hack。速度破解可以通过多种方式实现，比如简单地修改玩家。但是像内存的速度，计算机的时钟速度，这在Unity上是很难处理的。

​		这是防止它的方法：

- 在Server上检查移动速度。允许对网络条件有一定的容忍。许多游戏允许10-15%的容忍度，但任何高于这一水平的游戏都可能是一种速度攻击。

> 检查移动的 包的发送的速度,是否会比一般的快, 10%-15%是在 丢包/卡包 的情况,超过那就是对面网络差,既然网络环境差,那活该被判定作弊



## 机器人

​		如前所述，机器人是特别招人厌烦的，因为他们不需要任何真正的欺骗或利用Client-Authority。此外，如果你周围的人都是机器人，它们可能会破坏你的游戏生态，让玩家觉得游戏毫无乐趣。
​		这是防止它的方法：

- 使寻找内存位置变得困难。参见上面的章节。

- 偶尔调整一下你的内存布局。在玩家之间添加不必要的值。`生命值和玩家`。有时`法力`。

- 偶尔调整一下你的网络协议。最先进的机器人甚至不需要读取你的内存。它们直接使用游戏的`send/recv`功能。偶尔修改您的`NetworkMessage`操作码和布局，您将使逆向工程非常困难。
> 上面俩点就是经常修改包的id,和内存的位置, 也就是需要频繁的更新,简直搞笑

- 通过校验和、名称等检测已知的挂机程序的进程。

- - 注意，这通常会将你的游戏标记为病毒。游戏不应该寻找正在运行的进程。

- - 从最简单的形式来看，如果某人连续一周24/7地玩游戏，那么这个人可能是机器人，或者极少数情况下是网吧里的某个家伙。
  - 如果玩家总是在同一地点使用相同的路径或关卡，那么这可能是一个机器人。

- 在游戏中添加一个**举报按钮**。调查被举报的玩家。试着和他们谈谈，看他们是否有反应，等等。

- 在高度活跃的地方放置**诱饵怪物**。如果某个区域在一段时间内杀死了许多怪物，那就在该区域刷出一个外观明显不同但非常强大的怪物。正常玩家会注意到并暂时转移到其他地方。机器人会撞到它然后死掉。

- 

  ​	同样，这些都是对复杂问题的简化答案。如果你的游戏获得成功，这将是一场持久战。这没什么，只要你知道你在打一场战斗。



## 沉默,延迟检测

​		游戏所犯的最大错误之一是让用户知道何时检测到作弊或逆向工程工具。它所做的只是让逆向工程师知道在代码的哪里查找以便禁用检查。

​		如果我们完成了所有检测作弊和调试的工作，我们应该保持沉默，并利用这些信息。与其大声宣布作弊企图，不如悄悄地向Server发送一些信息。标记数据库中的玩家。

​		**不要**立即封禁或踢出任何人。更明智的做法是随机等待一段时间。

-  用户可能会在一个月内用不同的版本尝试多种作弊方法。
-  逆向工程师可能会使用不同的工具，以不同的方式修改游戏。

​       如果我们一个月只禁一次人，那么导致禁的原因就完全不明显了。这将带来巨大的周转时间让开发者来测试哪些作弊会被发现，哪些不会。

> 无声侦查是我们战胜作弊者最有力的工具。善用时间和信息。



## 免费游戏和付费游戏的比较

​		下面是我在自己的游戏中可能也会考虑的最后一点。虽然免费游戏能够吸引大量玩家，但如果你只是一个小型独立开发者，还没有准备好应对大量虚假账户和黑客，那么付费游戏也有其价值。

​		玩家必须一次性付费才能玩你的多人游戏，这给玩家带来了一个巨大的障碍，即黑客和作弊者如果被禁，就必须再次购买你的游戏。此外，它还添加了某种程度的验证，以确保人们不会只是反复创建帐户。如果需要的话，你可以禁止使用信用卡等。



## 总结

​		总而言之，作弊是一个复杂的话题，永远不会有最终的解决方案。在我看来，你所能服务的一切都是权威的。对于移动，至少要让它在某些时候具有Server-Authority，例如在游戏发布后，当你开始看到第一个速度攻击，或者当你有一些喘息的空间时。

​		一旦你的游戏获得成功，可能就会有人参与战斗。你可以做很多事来增加难度。

​		最终，这是努力与奖励的结果。你越是让作弊变得烦人，人们就越有可能不去打扰你，或者干脆转向更容易的目标。

​		这个主题可以写一整本书，但我希望你从中学到一些基础知识。